# newbie_draw
* 枚举和 model 配合
* Future then 和 await 不要同时使用
* json list 解析加上 try catch，防止后端异常数据格式或其他返回
```dart
class Request with BaseRemoteSource {
  /// 活动列表
  Future<List<ActivityListItem>> activityList() {
    final dioReq = dioClient.post(
      '/aiera/v2/hotdog/newbie_draw/activity_list',
    );
    return callApiWithErrorParser(dioReq).then((res) {
      try {
        ActivityListModel obj = ActivityListModel.fromJson(res.data);
        return obj.data ?? [];
      } catch (e) {
        logger.e(e.toString());
        return [];
      }
    });
  }

  /// 邀请记录列表
  Future<List<RecordListItem>> recordList({int page = 1, int pageSize = 10}) {
    final dioReq = dioClient.post(
      '/aiera/v2/hotdog/newbie_draw/record_list',
      data: {
        'page': page,
        'page_size': pageSize,
      },
    );
    return callApiWithErrorParser(dioReq).then((res) {
      try {
        RecordListModel obj = RecordListModel.fromJson(res.data);
        return obj.data ?? [];
      } catch (e) {
        logger.e(e.toString());
        return [];
      }
    });
  }

  /// 邀请人信息
  Future<UserInfoModel?> userInfo() {
    final dioReq = dioClient.post(
      '/aiera/v2/hotdog/newbie_draw/user_info',
    );
    return callApiWithErrorParser(dioReq).then(
      (res) => res.data['code'] == 0
          ? UserInfoModel.fromJson(res.data['data'])
          : null,
    );
  }
}
```

# prop
```dart
// web url encode
String originalUrl = 'https://www.example.com/搜索/编码测试';
String encodedUrl = Uri.encodeFull(originalUrl);
```

# predict_trends
* 
```yaml
# 每次更新打 tag 可获取最新包，或者是 commit hash(提交记录哈希值)
# 确保最新可 /Users/bd/.pub-cache/git/k_chart-36712b6b6cfba2a52043f51f7bae5c33b3e4852e 删除后 get，再打开看是否有最新代码
k_chart:
  git:
    url: https://github.com/helloDolin/k_chart.git
    ref: 0.0.2
```
* 原生端 pop 时，需要手动释放 timer
* list 拼装为 list 套 list，利用带排序的 Map，key 为 时间，value 为 [] （flutter_sticky_header）
* publish_to: none 消除 git 或 本地引用的警告

# shell_market
* ScreenUtil 导致 Scaffold 键盘无法弹起（需要设置 useInheritedMediaQuery: true,） 
* num、double 转 int， .toInt()，直接截取不会四舍五入
* 多个 Future 执行，如果不 await 也是乱序的，不用使用 Future.wait(),Future.wait()更适合 group 的场景
```dart
// 下拉刷新时记得执行 resetNoData
  final int pageSize = 10;
  int curPage = 1;
  List<OtherListItem> listData = [];
  bool canLoad = true;

void onRefresh() {
  reqData(isRefresh: true).then((_) {
    refreshController.refreshCompleted();
    refreshController.resetNoData();
  }).catchError((_) {
    refreshController.refreshFailed();
    refreshController.resetNoData();
  });
}

void onLoading() {
  if (canLoad) {
    reqData(isRefresh: false).then((_) {
      refreshController.loadComplete();
    }).catchError((_) {
      refreshController.loadFailed();
    });
  } else {
    refreshController.loadNoData();
  }
}

Future<void> reqData({bool isRefresh = false}) async {
  if (isRefresh) {
    curPage = 1;
    listData.clear();
  } else {
    curPage++;
  }

  List<PropListItem> res = await callDataService(
    req.propList(curPage, pageSize),
    onStart: () {},
    onComplete: () {},
  );
  listData.addAll(res);
  canLoad = res.length == pageSize;
  // 下拉刷新时不展示没有数据了
  if (!canLoad && !isRefresh) {
    refreshController.loadNoData();
  }
  update();
}
```

# 分页
是否最后一页求余方式是否有问题？有问题，求余为 0，页数刚好为 pagesize 的倍数会出问题
当前页不满一页也有问题：假设 size 为 10，距离刚好 30 条数据，会造成多调用一次上拉加载更多动作的接口